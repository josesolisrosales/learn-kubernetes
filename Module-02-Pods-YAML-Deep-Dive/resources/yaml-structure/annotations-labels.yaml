# Annotations and Labels Deep Dive
# This file demonstrates comprehensive patterns for labels and annotations

# =============================================================================
# SECTION 1: Standard Kubernetes Labels (Recommended)
# =============================================================================
apiVersion: v1
kind: Pod
metadata:
  name: standard-labels-example
  
  # Following the Kubernetes recommended labels
  # Reference: https://kubernetes.io/docs/concepts/overview/working-with-objects/common-labels/
  labels:
    # Core application labels
    app.kubernetes.io/name: web-server              # Name of the application
    app.kubernetes.io/instance: web-server-prod     # Unique instance identifier
    app.kubernetes.io/version: "2.1.3"             # Application version
    app.kubernetes.io/component: frontend           # Component within the architecture
    app.kubernetes.io/part-of: ecommerce-platform   # Higher level application
    app.kubernetes.io/managed-by: helm              # Tool being used to manage
    
    # Extended standard labels
    app.kubernetes.io/created-by: platform-team     # Who/what created this
    
    # Additional organizational labels
    environment: production                          # Environment designation
    tier: web                                       # Application tier
    team: frontend-team                             # Owning team
    cost-center: engineering                        # Cost allocation
    project: ecommerce-redesign                     # Project identifier
    
  annotations:
    # Standard Kubernetes annotations
    kubernetes.io/change-cause: "Update to version 2.1.3 with security patches"
    
    # Deployment annotations
    deployment.kubernetes.io/revision: "5"
    
    # Documentation and contact info
    documentation: "https://docs.company.com/web-server"
    contact: "frontend-team@company.com"
    
spec:
  containers:
  - name: web-server
    image: nginx:1.21
    resources:
      requests:
        memory: "128Mi"
        cpu: "100m"

---
# =============================================================================
# SECTION 2: Label Selectors and Service Discovery
# =============================================================================

# Pod with comprehensive labeling for service discovery
apiVersion: v1
kind: Pod
metadata:
  name: service-discovery-pod
  labels:
    # Service selection labels
    app: user-service                    # Primary application identifier
    version: v2                         # Version for canary deployments
    
    # Service mesh labels (Istio example)
    service: user-service
    service-version: v2
    
    # Environment and deployment labels
    environment: staging
    deployment: blue                    # Blue-green deployment identifier
    
    # Feature flags and configuration
    feature-auth: enabled
    feature-metrics: enabled
    feature-tracing: enabled
    
    # Traffic routing labels
    traffic-group: canary-10           # 10% canary traffic
    region: us-west
    
  annotations:
    # Service mesh configuration
    sidecar.istio.io/inject: "true"
    traffic.sidecar.istio.io/includeInboundPorts: "8080,9090"
    
    # Load balancer configuration
    service.beta.kubernetes.io/aws-load-balancer-type: "nlb"
    service.beta.kubernetes.io/aws-load-balancer-backend-protocol: "http"
    
spec:
  containers:
  - name: user-service
    image: user-service:v2
    ports:
    - containerPort: 8080
    - containerPort: 9090

---
# Service that selects based on multiple label criteria
apiVersion: v1
kind: Service
metadata:
  name: user-service-canary
  labels:
    app: user-service
    routing: canary
  annotations:
    description: "Routes 10% traffic to canary version"
    traffic.policy: "canary-10-percent"
spec:
  selector:
    app: user-service                  # Must match app label
    version: v2                       # Only select v2 pods
    traffic-group: canary-10          # Only canary traffic pods
  ports:
  - port: 80
    targetPort: 8080

---
# Service for stable traffic
apiVersion: v1
kind: Service
metadata:
  name: user-service-stable
  labels:
    app: user-service
    routing: stable
spec:
  selector:
    app: user-service
    version: v1                       # Only select v1 pods
  ports:
  - port: 80
    targetPort: 8080

---
# =============================================================================
# SECTION 3: Monitoring and Observability Annotations
# =============================================================================
apiVersion: v1
kind: Pod
metadata:
  name: monitoring-annotations-demo
  labels:
    app: monitored-application
    monitoring: enabled
    
  annotations:
    # Prometheus scraping configuration
    prometheus.io/scrape: "true"               # Enable Prometheus scraping
    prometheus.io/port: "9090"                 # Metrics port
    prometheus.io/path: "/metrics"             # Metrics endpoint path
    prometheus.io/scheme: "http"               # HTTP or HTTPS
    prometheus.io/interval: "30s"              # Scrape interval
    
    # Grafana dashboard configuration
    grafana.dashboard.id: "user-service-dashboard"
    grafana.dashboard.uid: "abc123"
    grafana.folder: "Application Dashboards"
    
    # Alert configuration
    alerting.rules: |
      - alert: HighErrorRate
        expr: rate(http_requests_total{status=~"5.."}[5m]) > 0.1
        for: 2m
        annotations:
          summary: High error rate detected
    
    # Jaeger tracing configuration
    jaeger.sampling.rate: "0.1"               # 10% sampling rate
    jaeger.service.name: "user-service"
    
    # Logging configuration
    logging.level: "info"
    logging.format: "json"
    logging.destination: "stdout"
    
    # SLI/SLO definitions
    slo.availability.target: "99.9"           # 99.9% availability target
    slo.latency.p99.target: "100ms"           # 99th percentile latency
    slo.error-rate.target: "0.1"              # 0.1% error rate target
    
    # Monitoring metadata
    monitor.contact: "platform-team@company.com"
    monitor.runbook: "https://runbooks.company.com/user-service"
    monitor.escalation: "https://oncall.company.com/platform-team"
    
spec:
  containers:
  - name: app
    image: user-service:latest
    ports:
    - containerPort: 8080
      name: http
    - containerPort: 9090
      name: metrics
    
    # Environment variables for observability
    env:
    - name: JAEGER_ENDPOINT
      value: "http://jaeger-collector:14268/api/traces"
    - name: METRICS_ENABLED
      value: "true"
    - name: LOG_LEVEL
      value: "info"
    
    resources:
      requests:
        memory: "128Mi"
        cpu: "100m"

---
# =============================================================================
# SECTION 4: Security and Compliance Annotations
# =============================================================================
apiVersion: v1
kind: Pod
metadata:
  name: security-annotations-demo
  labels:
    app: secure-application
    security-scan: passed
    
  annotations:
    # Security scanning information
    security.scan.image: "passed"
    security.scan.date: "2023-10-15T10:30:00Z"
    security.scan.tool: "trivy"
    security.scan.report: "https://security.company.com/reports/abc123"
    security.vulnerabilities.critical: "0"
    security.vulnerabilities.high: "0"
    security.vulnerabilities.medium: "2"
    security.vulnerabilities.low: "5"
    
    # Compliance information
    compliance.sox: "true"                    # SOX compliance
    compliance.pci: "false"                   # PCI DSS compliance
    compliance.gdpr: "true"                   # GDPR compliance
    compliance.hipaa: "false"                 # HIPAA compliance
    compliance.last-audit: "2023-09-01"
    
    # Pod Security Standards
    pod-security.kubernetes.io/enforce: "restricted"
    pod-security.kubernetes.io/enforce-version: "v1.24"
    pod-security.kubernetes.io/audit: "restricted"
    pod-security.kubernetes.io/warn: "restricted"
    
    # Network security
    network-policy.ingress.isolation: "strict"
    network-policy.egress.isolation: "strict"
    network-policy.allowed-sources: "frontend-pods,monitoring-system"
    
    # Data classification
    data.classification: "confidential"       # public, internal, confidential, restricted
    data.retention.policy: "7-years"
    data.encryption.required: "true"
    data.pii.present: "true"
    
    # Access control
    rbac.required: "true"
    service-account.name: "secure-app-sa"
    access.review.date: "2023-10-01"
    access.review.by: "security-team@company.com"
    
spec:
  serviceAccountName: secure-app-sa
  securityContext:
    runAsNonRoot: true
    runAsUser: 1000
    fsGroup: 2000
  
  containers:
  - name: secure-app
    image: secure-app:latest
    securityContext:
      allowPrivilegeEscalation: false
      readOnlyRootFilesystem: true
      capabilities:
        drop:
        - ALL
    
    resources:
      requests:
        memory: "64Mi"
        cpu: "50m"
      limits:
        memory: "128Mi"
        cpu: "100m"

---
# =============================================================================
# SECTION 5: CI/CD and Deployment Annotations
# =============================================================================
apiVersion: v1
kind: Pod
metadata:
  name: cicd-annotations-demo
  labels:
    app: cicd-demo
    deployment-strategy: rolling-update
    
  annotations:
    # CI/CD pipeline information
    ci.pipeline.id: "pipeline-12345"
    ci.pipeline.url: "https://ci.company.com/pipelines/12345"
    ci.build.number: "456"
    ci.build.url: "https://ci.company.com/builds/456"
    ci.build.duration: "3m45s"
    ci.build.status: "success"
    
    # Source code information
    git.commit.sha: "abc123def456789"
    git.commit.message: "Add new feature for user management"
    git.commit.author: "john.doe@company.com"
    git.commit.date: "2023-10-15T14:30:00Z"
    git.branch: "feature/user-management"
    git.tag: "v2.1.3"
    git.repository: "https://github.com/company/user-service"
    
    # Pull request information
    pr.number: "789"
    pr.title: "Add user management feature"
    pr.url: "https://github.com/company/user-service/pull/789"
    pr.author: "john.doe"
    pr.reviewers: "jane.smith,bob.johnson"
    
    # Deployment information
    deployment.timestamp: "2023-10-15T16:00:00Z"
    deployment.environment: "production"
    deployment.strategy: "rolling-update"
    deployment.version: "v2.1.3"
    deployment.rollback.enabled: "true"
    deployment.rollback.version: "v2.1.2"
    
    # Change management
    change.ticket: "CHG-123456"
    change.type: "normal"                     # emergency, normal, standard
    change.risk: "low"                        # low, medium, high
    change.approved-by: "change-board@company.com"
    change.implementation-date: "2023-10-15T16:00:00Z"
    change.rollback-plan: "Rollback to v2.1.2 if issues detected"
    
    # Feature flags
    feature.flag.new-ui: "true"
    feature.flag.advanced-search: "false"
    feature.flag.beta-features: "true"
    feature.flag.rollout-percentage: "25"
    
    # Configuration checksums (for change detection)
    config.checksum.configmap: "sha256:abc123..."
    config.checksum.secret: "sha256:def456..."
    config.checksum.environment: "sha256:ghi789..."
    
    # Deployment dependencies
    deployment.depends-on: "database-migration-job"
    deployment.blocks: "user-ui-deployment"
    deployment.notification.slack: "#deployments"
    deployment.notification.email: "platform-team@company.com"
    
spec:
  containers:
  - name: app
    image: user-service:v2.1.3
    env:
    - name: BUILD_VERSION
      value: "v2.1.3"
    - name: BUILD_NUMBER
      value: "456"
    - name: GIT_COMMIT
      value: "abc123def456789"
    
    resources:
      requests:
        memory: "128Mi"
        cpu: "100m"

---
# =============================================================================
# SECTION 6: Cost Management and Resource Optimization
# =============================================================================
apiVersion: v1
kind: Pod
metadata:
  name: cost-optimization-demo
  labels:
    app: cost-demo
    cost-optimization: enabled
    
  annotations:
    # Cost allocation
    cost.center: "engineering"
    cost.project: "user-management"
    cost.owner: "platform-team@company.com"
    cost.budget.monthly: "1000"              # USD per month
    cost.budget.alert.threshold: "80"        # Alert at 80% of budget
    
    # Resource optimization
    resource.optimization.enabled: "true"
    resource.right-sizing.recommendation: "Reduce CPU request to 50m"
    resource.usage.cpu.avg: "25m"            # Average CPU usage
    resource.usage.memory.avg: "64Mi"        # Average memory usage
    resource.efficiency.score: "85"          # Efficiency score (0-100)
    
    # Scaling information
    autoscaling.enabled: "true"
    autoscaling.min-replicas: "2"
    autoscaling.max-replicas: "10"
    autoscaling.target-cpu: "70"
    autoscaling.target-memory: "80"
    
    # Spot instance tolerance
    spot-instance.tolerated: "true"
    spot-instance.preference: "high"         # high, medium, low
    
    # Cluster optimization
    cluster.node-pool: "spot-instances"
    cluster.zone-preference: "us-west-2a,us-west-2b"
    cluster.instance-type-preference: "m5.large,m5.xlarge"
    
    # Business metrics
    business.revenue-impact: "medium"        # low, medium, high, critical
    business.customer-impact: "high"
    business.sla.tier: "gold"               # bronze, silver, gold, platinum
    
    # Resource tagging for cloud billing
    aws.cost.team: "platform"
    aws.cost.environment: "production"
    aws.cost.application: "user-service"
    
spec:
  containers:
  - name: app
    image: user-service:latest
    resources:
      requests:
        memory: "64Mi"                       # Right-sized based on usage
        cpu: "50m"                          # Right-sized based on usage
      limits:
        memory: "128Mi"
        cpu: "100m"
  
  # Tolerate spot instance interruptions
  tolerations:
  - key: "node.kubernetes.io/not-ready"
    operator: "Exists"
    effect: "NoExecute"
    tolerationSeconds: 300
  - key: "node.kubernetes.io/unreachable"
    operator: "Exists"
    effect: "NoExecute"
    tolerationSeconds: 300

---
# =============================================================================
# SECTION 7: Custom Application-Specific Labels and Annotations
# =============================================================================
apiVersion: v1
kind: Pod
metadata:
  name: custom-metadata-demo
  labels:
    # Application-specific labels
    app: order-processor
    microservice: order-management
    data-tier: transactional
    
    # Business domain labels
    business-unit: ecommerce
    product-line: retail
    customer-segment: enterprise
    
    # Technical architecture labels
    architecture-pattern: event-driven
    message-broker: kafka
    database-type: postgresql
    cache-type: redis
    
    # API and integration labels
    api-version: v2
    api-contract: openapi-3.0
    integration-type: rest-api
    
    # Performance characteristics
    compute-profile: cpu-intensive
    io-profile: high-throughput
    memory-profile: standard
    
    # Geographic and regulatory labels
    data-locality: us-west
    regulatory-zone: gdpr-compliant
    cross-border-data: "false"
    
  annotations:
    # Custom business annotations
    business.owner: "ecommerce-team@company.com"
    business.criticality: "high"
    business.disaster-recovery.rto: "15m"    # Recovery Time Objective
    business.disaster-recovery.rpo: "5m"     # Recovery Point Objective
    
    # Application-specific configuration
    app.config.database.connection-pool: "20"
    app.config.cache.ttl: "300"
    app.config.queue.batch-size: "100"
    app.config.retry.max-attempts: "3"
    
    # Integration endpoints
    app.upstream.payment-service: "https://payments.company.com/api/v2"
    app.upstream.inventory-service: "https://inventory.company.com/api/v1"
    app.downstream.notification-service: "https://notifications.company.com/api/v1"
    
    # Performance baselines
    perf.baseline.requests-per-second: "1000"
    perf.baseline.response-time.p95: "50ms"
    perf.baseline.error-rate: "0.1%"
    
    # Custom health check configuration
    health.startup.timeout: "60s"
    health.readiness.dependencies: "database,cache,message-queue"
    health.liveness.check-interval: "30s"
    
    # Backup and recovery
    backup.database.enabled: "true"
    backup.database.schedule: "0 2 * * *"
    backup.database.retention: "30d"
    recovery.procedure: "https://docs.company.com/recovery/order-processor"
    
spec:
  containers:
  - name: order-processor
    image: order-processor:v2.1.0
    ports:
    - containerPort: 8080
      name: http-api
    - containerPort: 9090
      name: metrics
    
    env:
    # Environment variables that mirror annotations
    - name: BUSINESS_UNIT
      value: "ecommerce"
    - name: SERVICE_VERSION
      value: "v2.1.0"
    - name: DATABASE_POOL_SIZE
      value: "20"
    
    resources:
      requests:
        memory: "256Mi"
        cpu: "200m"
      limits:
        memory: "512Mi"
        cpu: "400m"

---
# =============================================================================
# SECTION 8: Multi-Cluster and Federation Labels
# =============================================================================
apiVersion: v1
kind: Pod
metadata:
  name: multi-cluster-demo
  labels:
    # Cluster identification
    cluster.name: "production-west"
    cluster.region: "us-west-2"
    cluster.zone: "us-west-2a"
    cluster.provider: "aws"
    cluster.version: "1.28"
    
    # Federation labels
    federation.cluster-set: "production-clusters"
    federation.traffic-policy: "failover"
    federation.weight: "100"
    
    # Cross-cluster service discovery
    service.cross-cluster: "enabled"
    service.cluster-dns: "production-west.company.com"
    
    # Multi-region configuration
    region.primary: "us-west-2"
    region.backup: "us-east-1"
    region.data-residency: "us"
    
  annotations:
    # Multi-cluster networking
    cluster.network.cni: "calico"
    cluster.network.service-mesh: "istio"
    cluster.ingress.controller: "nginx"
    
    # Cross-cluster policies
    policy.network.cross-cluster: "restricted"
    policy.data.cross-region: "encrypted"
    policy.backup.cross-region: "enabled"
    
    # Disaster recovery
    dr.strategy: "active-passive"
    dr.primary-cluster: "production-west"
    dr.secondary-cluster: "production-east"
    dr.sync.enabled: "true"
    
spec:
  containers:
  - name: app
    image: multi-cluster-app:latest
    resources:
      requests:
        memory: "128Mi"
        cpu: "100m"